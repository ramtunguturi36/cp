*************************************************************************************
**6.permutation of the vertices

import java.io.*;  
import java.util.*; 

class TopologicalSort {  
    private int V; 
    
    private ArrayList<ArrayList<Integer>> adj; 
    
    TopologicalSort(int v) { 
        V = v; 
        adj = new ArrayList<ArrayList<Integer>>(v);  
        for (int i = 0; i < v; ++i) 
            adj.add(new ArrayList<Integer>()); 
    } 
    
    
    void addEdge(int v, int w) { 
        adj.get(v).add(w); 
    } 
    
    
    void topologicalSortUtil(int v, boolean visited[], Stack<Integer> stack) { 
        
        visited[v] = true; 
        Integer i; 
        
        
        Iterator<Integer> it = adj.get(v).iterator();  
        while (it.hasNext()) { 
            i = it.next(); 
            if (!visited[i]) 
                topologicalSortUtil(i, visited, stack); 
        } 
        
        
        stack.push(v); 
    } 
    
    void topologicalSort() { 
        Stack<Integer> stack = new Stack<Integer>(); 
        
        
        boolean visited[] = new boolean[V]; 
        for (int i = 0; i < V; i++) 
            visited[i] = false; 
        
        
        for (int i = 0; i < V; i++) 
            if (visited[i] == false) 
                topologicalSortUtil(i, visited, stack); 
        
        
        while (stack.empty() == false) 
            System.out.print(stack.pop() + " "); 
    } 
    
    
    public static void main(String args[]) {  
        TopologicalSort g = new TopologicalSort(6);  
        g.addEdge(5, 2); 
        g.addEdge(5, 0); 
        g.addEdge(4, 0); 
        g.addEdge(4, 1); 
        g.addEdge(2, 3); 
        g.addEdge(3, 1); 
        
        System.out.println("Following is a Topological " + "sort of the given graph"); 
        g.topologicalSort(); 
    } 
}

**************************************************************************************************************
**7. articulation points of a graph

import java.util.*;

class Graph {
    static int time;
    
    static void addEdge(ArrayList<ArrayList<Integer>> adj, int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);
    }
    
    static void APUtil(ArrayList<ArrayList<Integer>> adj, int u, boolean visited[], 
                      int disc[], int low[], int parent, boolean isAP[]) {
        
        int children = 0;
        
        
        visited[u] = true;
        
        
        disc[u] = low[u] = ++time;
        
        
        for (Integer v : adj.get(u)) {
            
            if (!visited[v]) {
                children++;
                APUtil(adj, v, visited, disc, low, u, isAP);
                
                
                low[u] = Math.min(low[u], low[v]);
                
                
                if (parent != -1 && low[v] >= disc[u])
                    isAP[u] = true;
            }
            
            else if (v != parent)
                low[u] = Math.min(low[u], disc[v]);
        }
        
        
        if (parent == -1 && children > 1)
            isAP[u] = true;
    }
    
    static void AP(ArrayList<ArrayList<Integer>> adj, int V) {
        boolean[] visited = new boolean[V];
        int[] disc = new int[V];
        int[] low = new int[V];
        boolean[] isAP = new boolean[V];
        int time = 0, par = -1;
        
        
        for (int u = 0; u < V; u++)
            if (visited[u] == false)
                APUtil(adj, u, visited, disc, low, par, isAP);
        
        for (int u = 0; u < V; u++)
            if (isAP[u] == true)
                System.out.print(u + " ");
        System.out.println();
    }
    
    public static void main(String[] args) {
        
        int V = 5;
        ArrayList<ArrayList<Integer>> adj1 = new ArrayList<ArrayList<Integer>>(V);
        
        for (int i = 0; i < V; i++)
            adj1.add(new ArrayList<Integer>());
        
        addEdge(adj1, 1, 0);
        addEdge(adj1, 0, 2);
        addEdge(adj1, 2, 1);
        addEdge(adj1, 0, 3);
        addEdge(adj1, 3, 4);
        
        System.out.println("Articulation points in the graph");
        AP(adj1, V);
    }
}

**************************************************************************************************
**8.permutation of a string forms a palindrome 

import java.util.*;

class PermutationPalindrome {
    public boolean canPermutePalindrome(String s) {
        int bitMask = 0;
        for (int i = 0; i < s.length(); i++) {
            bitMask ^= 1 << (s.charAt(i) - 'a' + 1);
        }
        return Integer.bitCount(bitMask) <= 1;
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println(new PermutationPalindrome().canPermutePalindrome(sc.next()));
        sc.close();
    }
}

**************************************************************************************************
**9.return all index pairs [i,j]
import java.util.*;

class Solution {
    public int[][] indexPairs(String text, String[] words) {
        List<int[]> indexPairsList = new ArrayList<>();
        
        for (String word : words) {
            int wordLength = word.length();
            int curIndex = 0;
            
            while (curIndex >= 0) {
                curIndex = text.indexOf(word, curIndex);
                if (curIndex >= 0) {
                    indexPairsList.add(new int[]{curIndex, curIndex + wordLength - 1});
                    curIndex++;
                }
            }
        }
        
        
        Collections.sort(indexPairsList, new Comparator<int[]>() {
            public int compare(int[] array1, int[] array2) {
                return (array1[0] != array2[0]) ? 
                       (array1[0] - array2[0]) : 
                       (array1[1] - array2[1]);
            }
        });
        
        
        int[][] indexPairs = new int[indexPairsList.size()][2];
        for (int i = 0; i < indexPairs.length; i++) {
            int[] pair = indexPairsList.get(i);
            indexPairs[i][0] = pair[0];
            indexPairs[i][1] = pair[1];
        }
        
        return indexPairs;
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        
        System.out.println("Enter the text:");
        String text = sc.nextLine();
        
        System.out.println("Enter the words separated by spaces:");
        String[] words = sc.nextLine().split(" ");
        
        int[][] result = new Solution().indexPairs(text, words);
        
        System.out.println("Index pairs:");
        for (int[] res : result) {
            System.out.print(Arrays.toString(res) + " ");
        }
        
        sc.close();
    }
}

*****************************************************************************************************

**10.LCA

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        
        System.out.println("Enter tree nodes separated by spaces (-1 for null):");
        String[] arr = sc.nextLine().split(" ");
        
        System.out.println("Enter two node values to find LCA:");
        String[] persons = sc.nextLine().split(" ");
        
        
        List<Integer> v = new ArrayList<>();
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            v.add(Integer.parseInt(arr[i]));
        }
        
        
        Node root = new Node(v.get(0));
        Node P1 = new Node(Integer.parseInt(persons[0]));
        Node P2 = new Node(Integer.parseInt(persons[1]));
        
        Queue<Node> q = new LinkedList<>();
        q.add(root);
        int j = 1;
        
        while (j < n && !q.isEmpty()) {
            Node temp = q.poll();
            
            if (v.get(j) != -1) {
                temp.left = new Node(v.get(j));
                q.add(temp.left);
            }
            j++;
            
            if (j < n && v.get(j) != -1) {
                temp.right = new Node(v.get(j));
                q.add(temp.right);
            }
            j++;
        }
        
        
        Node res = new Solution().lowestCommonAncestor(root, P1, P2);
        System.out.println("Lowest Common Ancestor: " + res.data);
        
        sc.close();
    }
}

class Node {
    public int data;
    public Node left;
    public Node right;
    
    public Node(int value) {
        data = value;
        left = null;
        right = null;
    }
}

class Solution {
    public Node lowestCommonAncestor(Node root, Node P1, Node P2) {
        if (root == null) {
            return null;
        }
        
        if (P1.data == root.data || P2.data == root.data) {
            return root;
        }
        
        Node left = lowestCommonAncestor(root.left, P1, P2);
        Node right = lowestCommonAncestor(root.right, P1, P2);
        
        if (left == null) {
            return right;
        } else if (right == null) {
            return left;
        } else {
            return root;
        }
    }
}


***********************************************************************************

**11. Longest Increasing Path in a Matrix. 
import java.util.*;

public class Solution {
    private int[] dx = new int[] {0, 0, -1, 1};
    private int[] dy = new int[] {1, -1, 0, 0};
    
    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return 0;
        }
        
        int longest = 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m][n]; 
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                longest = Math.max(longest, dfs(i, j, matrix, dp));
            }
        }
        
        return longest;
    }
    
    private int dfs(int row, int col, int[][] matrix, int[][] dp) {
        if (dp[row][col] > 0) {
            return dp[row][col]; 
        }
        
        int m = matrix.length;
        int n = matrix[0].length;
        int currentLongest = 0;
        
        
        for (int c = 0; c < 4; c++) {
            int i = row + dx[c];
            int j = col + dy[c];
            
            if (i >= 0 && i < m && j >= 0 && j < n && 
                matrix[row][col] < matrix[i][j]) {
                currentLongest = Math.max(currentLongest, dfs(i, j, matrix, dp));
            }
        }
        
        dp[row][col] = 1 + currentLongest;
        return dp[row][col];
    }
    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        
        System.out.println("Enter matrix dimensions (rows columns):");
        int m = sc.nextInt();
        int n = sc.nextInt();
        
        System.out.println("Enter matrix values row by row:");
        int[][] matrix = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = sc.nextInt();
            }
        }
        
        System.out.println("Longest increasing path length: " + 
                          new Solution().longestIncreasingPath(matrix));
        
        sc.close();
    }
}
*****************************************************************************************

**12.Lexicographically smallest equivalent string.

import java.util.*;

class Solution {
    public String smallestEquivalentString(String A, String B, String S) {
        
        int[] parent = new int[26];
        for (int i = 0; i < 26; i++) {
            parent[i] = i;
        }
        
        
        for (int i = 0; i < A.length(); i++) {
            int a = A.charAt(i) - 'a';
            int b = B.charAt(i) - 'a';
            union(parent, a, b);
        }
        
        
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < S.length(); i++) {
            char c = S.charAt(i);
            result.append((char)('a' + find(parent, c - 'a')));
        }
        
        return result.toString();
    }
    
    private int find(int[] parent, int idx) {
        
        while (parent[idx] != idx) {
            parent[idx] = parent[parent[idx]];  
            idx = parent[idx];
        }
        return idx;
    }
    
    private void union(int[] parent, int a, int b) {
        int rootA = find(parent, a);
        int rootB = find(parent, b);
        
        
        if (rootA < rootB) {
            parent[rootB] = rootA;
        } else {
            parent[rootA] = rootB;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        System.out.println("Enter first string (A):");
        String A = sc.next();
        
        System.out.println("Enter second string (B):");
        String B = sc.next();
        
        System.out.println("Enter base string (S):");
        String substr = sc.next();
        
        Solution solution = new Solution();
        String result = solution.smallestEquivalentString(A, B, substr);
        
        System.out.println("Lexicographically smallest equivalent string:");
        System.out.println(result);
        
        sc.close();
    }

}
***********************************************************************

academeic:

1.connected components(unionfind)
import java.util.*;

class UnionFind {
    int[] parent;
    int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path Compression
        }
        return parent[x];
    }

    public void unionfind(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;

        if (rank[px] > rank[py]) {
            parent[py] = px;
            rank[px] += rank[py];
        } else {
            parent[px] = py;
            rank[py] += rank[px];
        }
    }
}

public class ConnectedComponents {

    public static int countComponents(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        int components = n;

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            if (uf.find(u) != uf.find(v)) {
                uf.unionfind(u, v);
                components--;
            }
        }
        return components;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // Number of nodes
        int e = sc.nextInt(); // Number of edges
        int[][] edges = new int[e][2];

        for (int i = 0; i < e; i++) {
            edges[i][0] = sc.nextInt();
            edges[i][1] = sc.nextInt();
        }

        System.out.println(countComponents(n, edges));
    }
}
*************************************************************************

**2.distinct islands

import java.util.*;

class UnionFind {
    int[] parent;
    int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    public void unionfind(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;

        if (rank[px] > rank[py]) {
            parent[py] = px;
            rank[px] += rank[py];
        } else {
            parent[px] = py;
            rank[py] += rank[px];
        }
    }
}

public class DistinctIslandsUF {

    public static int numDistinctIslands(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int rows = grid.length;
        int cols = grid[0].length;
        UnionFind uf = new UnionFind(rows * cols);
        List<int[]> landPositions = new ArrayList<>();

        int[][] directions = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    int index = i * cols + j;
                    landPositions.add(new int[]{i, j});

                    for (int[] dir : directions) {
                        int ni = i + dir[0];
                        int nj = j + dir[1];
                        if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && grid[ni][nj] == 1) {
                            int nIndex = ni * cols + nj;
                            if (uf.find(index) != uf.find(nIndex)) {
                                uf.unionfind(index, nIndex);
                            }
                        }
                    }
                }
            }
        }

        Map<Integer, List<int[]>> islandMap = new HashMap<>();
        for (int[] pos : landPositions) {
            int root = uf.find(pos[0] * cols + pos[1]);
            islandMap.computeIfAbsent(root, k -> new ArrayList<>()).add(pos);
        }

        Set<String> uniqueIslands = new HashSet<>();
        for (List<int[]> island : islandMap.values()) {
            int[] base = island.get(0);
            List<String> shape = new ArrayList<>();
            for (int[] cell : island) {
                int dx = cell[0] - base[0];
                int dy = cell[1] - base[1];
                shape.add(dx + "," + dy);
            }
            Collections.sort(shape);
            uniqueIslands.add(String.join(";", shape));
        }

        return uniqueIslands.size();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] grid = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = sc.nextInt();
            }
        }

        System.out.println(numDistinctIslands(grid));
    }
}
3.connected components(graphs)
import java.util.*;

public class ConnectedComponents {
    static void addEdge(ArrayList<ArrayList<Integer>> adjList, int u, int v) {
        adjList.get(u).add(v);
        adjList.get(v).add(u);
    }

    static void dfs(int node, ArrayList<ArrayList<Integer>> adjList, boolean[] visited) {
        visited[node] = true;
        System.out.print(node + " ");
        for (int neighbor : adjList.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor, adjList, visited);
            }
        }
    }

    static void connectedComponents(int V, ArrayList<ArrayList<Integer>> adjList) {
        boolean[] visited = new boolean[V];
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, adjList, visited);
                System.out.println();
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter number of vertices: ");
        int V = sc.nextInt();

        System.out.println("Enter number of edges: ");
        int E = sc.nextInt();

        // Initialize adjacency list in main
        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adjList.add(new ArrayList<>());
        }

        System.out.println("Enter edges (pair of vertices): ");
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            addEdge(adjList, u, v);
        }

        System.out.println("Following are connected components:");
        connectedComponents(V, adjList);

        sc.close();
    }
}
****************************************************************
**4.bridges
import java.util.*;

public class FindingBridges {
    static final int NIL = -1;

    static void addEdge(List<List<Integer>> adj, int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);
    }

    static void bridgeUtil(int u, List<List<Integer>> adj, boolean[] visited,
                           int[] disc, int[] low, int[] parent, int[] time) {
        visited[u] = true;
        disc[u] = low[u] = ++time[0];

        for (int v : adj.get(u)) {
            if (!visited[v]) {
                parent[v] = u;
                bridgeUtil(v, adj, visited, disc, low, parent, time);

                low[u] = Math.min(low[u], low[v]);

                if (low[v] > disc[u]) {
                    System.out.println(u + " " + v);
                }
            } else if (v != parent[u]) {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }

    static void findBridges(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        int[] disc = new int[V];
        int[] low = new int[V];
        int[] parent = new int[V];
        int[] time = new int[1];  // Use array to simulate passing by reference

        Arrays.fill(parent, NIL);

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                bridgeUtil(i, adj, visited, disc, low, parent, time);
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter number of vertices: ");
        int V = sc.nextInt();

        System.out.println("Enter number of edges: ");
        int E = sc.nextInt();

        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }

        System.out.println("Enter edges (pair of vertices): ");
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            addEdge(adj, u, v);
        }

        System.out.println("Bridges in graph:");
        findBridges(V, adj);

        sc.close();
    }
}
********************************************************************
**5.maxflow

import java.util.*;

public class MaxFlowFordFulkerson_DFS {
    static int V;
    
    boolean dfs(int[][] rGraph, int s, int t, int[] parent) {
        boolean[] visited = new boolean[V];
        Stack<Integer> stack = new Stack<>();
        stack.push(s);
        visited[s] = true;
        parent[s] = -1;
        
        while (!stack.isEmpty()) {
            int u = stack.pop();
            for (int v = 0; v < V; v++) {
                if (!visited[v] && rGraph[u][v] > 0) {
                    stack.push(v);
                    parent[v] = u;
                    visited[v] = true;
                    if (v == t) return true;
                }
            }
        }
        return false;
    }

    int fordFulkerson(int[][] graph, int s, int t) {
        int u, v;
        int[][] rGraph = new int[V][V];
        
        for (u = 0; u < V; u++)
            for (v = 0; v < V; v++)
                rGraph[u][v] = graph[u][v];
                
        int[] parent = new int[V];
        int maxFlow = 0;
        
        while (dfs(rGraph, s, t, parent)) {
            int pathFlow = Integer.MAX_VALUE;
            
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                pathFlow = Math.min(pathFlow, rGraph[u][v]);
            }
            
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                rGraph[u][v] -= pathFlow;
                rGraph[v][u] += pathFlow;
            }
            
            maxFlow += pathFlow;
        }
        return maxFlow;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        System.out.println("Enter number of vertices:");
        V = sc.nextInt();
        
        int[][] graph = new int[V][V];
        
        System.out.println("Enter the adjacency matrix of the directed graph:");
        for (int i = 0; i < V; i++)
            for (int j = 0; j < V; j++)
                graph[i][j] = sc.nextInt();
        
        System.out.println("Enter source and sink:");
        int s = sc.nextInt();
        int t = sc.nextInt();
        
        System.out.println("Maximum flow: " + 
            new MaxFlowFordFulkerson_DFS().fordFulkerson(graph, s, t));
        
        sc.close();
    }
}
***********************************************************************
6.courseshedule 1

import java.util.*;

public class CourseSchedule_I {
    public static boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] indegree = new int[numCourses];

        for (int i = 0; i < numCourses; i++)
            graph.add(new ArrayList<>());

        for (int[] pre : prerequisites) {
            graph.get(pre[1]).add(pre[0]);
            indegree[pre[0]]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0)
                queue.offer(i);
        }

        int finished = 0;
        while (!queue.isEmpty()) {
            int curr = queue.poll();
            finished++;

            for (int next : graph.get(curr)) {
                indegree[next]--;
                if (indegree[next] == 0)
                    queue.offer(next);
            }
        }

        return finished == numCourses;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int numCourses = sc.nextInt();
        int m = sc.nextInt();

        int[][] prerequisites = new int[m][2];
        for (int i = 0; i < m; i++) {
            prerequisites[i][0] = sc.nextInt();
            prerequisites[i][1] = sc.nextInt();
        }

        System.out.println(canFinish(numCourses, prerequisites));
    }
}


************************************************************************
7.courseshedule2


import java.util.*;

public class CourseSchedule_II {

    public static int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] indegree = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }

        for (int[] prerequisite : prerequisites) {
            graph.get(prerequisite[1]).add(prerequisite[0]);
            indegree[prerequisite[0]]++; 
        }

        

        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.add(i);
            }
        }

        int[] order = new int[numCourses];
        int idx = 0;

        while (!q.isEmpty()) {
            int node = q.poll();
            order[idx++] = node;

            for (int nbr : graph.get(node)) {
                indegree[nbr]--;
                if (indegree[nbr] == 0) {
                    q.add(nbr);
                }
            }
        }

        if (idx < numCourses) {
            return new int[]{};  // Cycle detected

        }
        return order;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int numCourses = sc.nextInt();
        int m = sc.nextInt();
        int[][] prerequisites = new int[m][2];

        for (int i = 0; i < m; i++) {
            prerequisites[i][0] = sc.nextInt();
            prerequisites[i][1] = sc.nextInt();
        }

        System.out.println(Arrays.toString(findOrder(numCourses, prerequisites)));
    }
}

*************************************************************************
8.parallelcourses1

import java.util.*;

public class ParallelCoursesI {
    public static int minimumSemesters(int n, int[][] relations) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[n + 1];

        for (int i = 0; i <n+1; i++)
            graph.add(new ArrayList<>());

        for (int[] relation : relations) {
            graph.get(relation[0]).add(relation[1]);
            inDegree[relation[1]]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <n+1; i++)
            if (inDegree[i] == 0)
                queue.offer(i);

        int semesters = 0, coursesTaken = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int course = queue.poll();
                coursesTaken++;

                for (int neighbor : graph.get(course)) {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] == 0)
                        queue.offer(neighbor);
                }
            }
            semesters++;
        }

        return coursesTaken == n ? semesters : -1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();

        int[][] relations = new int[m][2];
        for (int i = 0; i < m; i++) {
            relations[i][0] = sc.nextInt();
            relations[i][1] = sc.nextInt();
        }

        System.out.println(minimumSemesters(n, relations));
    }
}

************************************************************************
9.parallelcourses2
import java.util.*;

public class ParallelCoursesII {
    public static int minimumSemesters(int n, int[][] relations, int k) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[n + 1];

        for (int i = 0; i <n+1; i++)
            graph.add(new ArrayList<>());

        for (int[] relation : relations){
            graph.get(relation[0]).add(relation[1]);
            inDegree[relation[1]]++;

        }

        PriorityQueue<Integer> availableCourses = new PriorityQueue<>();
        for (int i = 1; i <n+1; i++)
            if (inDegree[i] == 0)
                availableCourses.offer(i);

        int semesters = 0, coursesTaken = 0;

        while (coursesTaken < n) {
            int take = Math.min(availableCourses.size(), k);
            List<Integer> takenThisSemester = new ArrayList<>();

            for (int i = 0; i < take; i++) {
                int course = availableCourses.poll();
                takenThisSemester.add(course);
                coursesTaken++;
            }

            for (int course : takenThisSemester) {
                for (int neighbor : graph.get(course)) {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] == 0)
                        availableCourses.offer(neighbor);
                }
            }

            semesters++;
        }

        return semesters;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();

        int[][] relations = new int[m][2];
        for (int i = 0; i < m; i++) {
            relations[i][0] = sc.nextInt();
            relations[i][1] = sc.nextInt();
        }

        int k = sc.nextInt();

        System.out.println(minimumSemesters(n, relations, k));
    }
}

*************************************************************************
10.frequent words
import java.util.*;

class Node {
    public char c;
    public boolean isWord;
    public int count;
    public Node[] children;
    public String str;

    public Node(char c) {
        this.c = c;
        this.isWord = false;
        this.count = 0;
        children = new Node[26];
        str = "";
    }
}

class Trie {
    public Node root;

    public Trie() {
        this.root = new Node('\0');
    }

    public void insert(String word) {
        Node curr = root;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (curr.children[c - 'a'] == null) {
                curr.children[c - 'a'] = new Node(c);
            }
            curr = curr.children[c - 'a'];
        }
        curr.isWord = true;
        curr.count += 1;
        curr.str = word;
    }

    public void traverse(Node root, PriorityQueue<Node> pq) {
        if (root.isWord) {
            pq.offer(root);
        }
        for (int i = 0; i < 26; i++) {
            if (root.children[i] != null) {
                traverse(root.children[i], pq);
            }
        }
    }
}

public class FrequentWord {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line1 = sc.nextLine();
        int p = sc.nextInt();
        String[] words = line1.split(",");

        Trie t = new Trie();
        PriorityQueue<Node> pq = new PriorityQueue<>(
            (a, b) -> {
                if (a.count != b.count) {
                    return b.count - a.count; // Higher count first
                }
                return a.str.compareTo(b.str); // Lex order if counts are equal
            }
        );

        for (int i = 0; i < words.length; i++) {
            t.insert(words[i]);
        }

        t.traverse(t.root, pq);
        List<String> res = new ArrayList<>();
        int k = 0;
        while (k++ < p && !pq.isEmpty()) {
            res.add(pq.poll().str);
        }
        System.out.println(res);
    }
}
***********************************************************************
11.longestword

import java.util.*;

class Solution {
    Trie root = new Trie();
    String res = "";

    public String longestWord(String[] words) {
        for (String word : words) addWord(word);
        for (String word : words) searchPrefix(word);
        return res;
    }

    private void searchPrefix(String word) {
        Trie cur = root;
        for (char c : word.toCharArray()) {
            cur = cur.children[c - 'a'];
            if (!cur.isWord) return;
        }
        if (res.length() < word.length() || 
            (res.length() == word.length() && res.compareTo(word) > 0)) {
            res = word;
        }
    }

    private void addWord(String word) {
        Trie cur = root;
        for (char c : word.toCharArray()) {
            if (cur.children[c - 'a'] == null) {
                cur.children[c - 'a'] = new Trie();
            }
            cur = cur.children[c - 'a'];
        }
        cur.isWord = true;
    }
}

class Trie {
    Trie[] children = new Trie[26];
    boolean isWord;
}

class LongestWord {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String[] dict = sc.nextLine().split(" ");
        System.out.println(new Solution().longestWord(dict));
    }
}
*************************************************************************

